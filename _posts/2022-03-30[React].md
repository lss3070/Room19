---
title: "[React] React 18버전에서의 바뀐점"
subtitle: "React"
layout: post
auther: "Hux"
header-style: text
catalog: true
tags:
    Javascript
    HeadlessBrowser
---


안녕하세요 어제부로 리액트 18버전이 정식 버전으로 바뀌었습니다.👏👏👏
React 18버전에서 어떤게 바뀌었는지 어떤 기능이 새로 생겼는지 알아보죠!!


//초안 리스트
1. automatic batching for fewer renders

- 이제 settimeout이나 promise내에서도 react의 비동기 hook을 이용할 수 있게 되었습니다. 
- settimeout 이나 promise 함수같은 경우 setstate에서도 처리됨.
기존에 settimeout안에서의 useState는 호출되었던 상태만 불러로오고 중간에 값이 바뀌면 반영이 되지 않았지만 18버전에서는 바뀌게 되었다.
- 동기식으로 처리를 원하는 경우에는 flushSync을 이용하여 처리해 주면 됩니다.

2. ssr support for suspense 모드sus
suspense는

나쁜 예시
* 특정 데이터 fetch에 대한 것이 아닙니다.
* suspense는 데이터 불러오기 작업과 뷰레이어를 결합해 주지 않는다.
UI 상에서 로딩상태를 표시 할 수 있도록 조정하는 것을 돕지만 이는 네트워크 로직을 react에 종속 시키는 것은 아니다.

유용한 예시
* 데이터 fetch라이브러리
---
* 의도적으로 설계된 로딩상태
---
* 경쟁상태(race condition)을 피할 수 있도록 돕는다.
---
경쟁산태란 무엇인가?
위키백과에 따르면 `공유 자원에 대해 여러개의 프로세스가 동시에 접근을 시도 할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태`이라고 나와있다.



예시1. 렌더링 직후 불러오기
렌더링 직후 불러오기(Suspense 미사용)
```

```
불러오기 이후 렌더링(Suspense 미사용)

불러올 때 렌더링(Suspense 사용)



suspense는 data fecthing 라이브러리의 워터폴 현상을 막아준다.


공식문서 참조..
8. concurrent 모드

필터링을 이용한 검색 기능을 만든다고 생각하면 디바운싱이나 스로틀을 이용하여
특정 최대 빈도수로 업데이트를하거나 사용자가 타이핑을 멈추고 나서만 목록을 업데이트 합니다. 하지만 성능이 안좋은 곳에서는 여전히 버벅거릴 것이며 디바운싱이나 스로틀링이 최적의 방식은 아닙니다.
(버벅거리는 이유는 렌더링이 시작되게 되면 중간에 중단을 할 수가 없기 때문입니다.)

concurrent모드는 렌더링을 인터럽트 가능하도록 만듬으로써 사용자가 다른키를 누를때 React는 브라우저 텍스트 입력을 업데이트 하는것을 차단할 필요가 없습니다.


결과적으론 react를 사용하는 방식은 이전과 똑같습니다.prop및 state와 같은 개념은 근복적으로 동일하게 작동이 되며 react는 휴리스틱을 사용하여 업데이트의 급함 정도만 결정하고 몇줄의 코드를 수정해서 사용자가 모든 상호작용에 대해 원하는 사용자의 경험을 얻을 수 있도록 합니다.

동시성
---

사용되는것 useTransition()훅

리액트는 ui렌더링 도중 렌더링 이외의 모든 작업을 차단한다.

대부분의 개발자들이 메모이제이션이나 디바운싱의 기법을 사용해서 사용자의 경험을 개선시키고자 하겠지만, 이는 주된 문제해결을 뒤로 미뤄두는 것일 뿐입니다. 렌더링은 여전히 길을 가로막는 큰 트럭과 같은 존재입니다.

동시성이란 결국 여러 작업들을 처리 할 수 있도록 작업들을 작은 조각들로 나누는 방법이고 react에서 이제 하려고 하는것.
즉 렌더링 과정을 더 작은 작업들로 나누고 스케줄러를 통해서 각 작업들에 중요도에 따른 우선순위를 정합니다.(Time-slicing)라고 부릅니다.

이렇게하면 concurrent react가 아래것들을 할 수 있게 됩니다.
* 메인 스레드를 블록하지 않는다.
* 동시에 여러 작업들을 처리하고 우선 순위에 따라 각 작업들 간에 전환할 수 있다.
* 최종 결과로 확정하지 않고도 부분적으로 트리를 렌더링 할 수 있다.


새로운 hook 기능

1. useTransition
(suspense와 함께 덜중요한 상태의 업데이트를 늦추는 것이 가능.)



2. useDeferredValue

3. useId
- server에서 생성한 react tree와 client에서 그린 react treetkdldp hydration이 원할하게 할 수 있도록 일관적인 id가 생성된다.

*hydration이란? 서버사이드 렌더링으로 만들어진 정적인 html이 state로 동적인 상태변화를 넣어주는 작업
CSR일 경우에는 상관이 없지만 SSR인 경우에는 사용을 고려해야한다.
Rehydration을 검색!!

4. useInsertionEffect
- react의 컴포넌트가 그려지는 순서를 보면 render -> useLayoutEffect-> commit -> useEffect

일반적으로 useLayoutEffect는 
를 사용할 때 ref에 대한 접근을 할 수가 없다.

기본적으로 react를 개발할 때 css library를 개발하지 않는 한 이 hook을 쓸 필요는 없다고 한다.

5. useSyncExternalStore

- react에선 internalSource는 props,state,context같은 것이 있다.



