---
title: "[React] NextJS 13 변경점 (2)"
subtitle: "React"
layout: post
auther: "Hux"
header-style: text
catalog: true
tags:
    React
    NextJs

---
개요
---

안녕하세요 몇일전에 NextJS가 13버전이 발표가 되었습니다. 
아직까진 정식 버전은 아니고 베타 버전이지만 NextJS에서 몇가지 부분이 바뀌어서 한번 적어보게되엇습니다.

먼저 NexJs 공식 문서상으로는 간단하게 5가지로 간추려집니다.

```
* app/Directory - layouts,react server components,streaming
* Turbopack - webpack과 비교해서 700배 빠른 모듈 번들러
* New next/image - 지연로딩을 좀 더 빠르게 만들었습니다.
* New next/font - layoutshift 현상이 없어진 자체 호스트 글꼴
* Imporved next/link - link태그 내부에 a태그 간소화
```

자 이제 세세하게 알아보죠

라우팅 시스템의 변화!
---
NextJS 13에서의 가장 큰 변화인거 같습니다.이전과 같이 파일 시스템 기반의 라우팅을 사용하지만 달라진것이있다면 기존에는 pages폴더를 기반으로 하여 라우팅이 구현 되었지만
app을 기반으로 해서 바뀐 폴더구조와 다양하게 추가된 예약파일들입니다.

app폴더는 다음과 같은 기능들을 포함하고 있습니다.

; ```
; Layouts 이동
; Server Component 이동 // pages폴더에서는 지원이 안돼지만 app폴더에서는 React Server Component 로드된다.
; Streaming 이동
; Support for Data Fecthing 이동
; ```

먼저 이전의 라우팅 폴더 구조에 대해 살펴보시죠


![기존 라우팅]({{site.url}}/img/react/next13/routing-today.avif)

위 그림과 같이 이전 폴더구조에서는 page기반의 폴더 구조였습니다.

업데이트 된 13버전에서는 라우팅되는 최상위 폴더에 app디렉토리가 존재하며 하위단에 폴더별로 라우팅을 정의해서 사용되어집니다.

![바뀐 라우팅]({{site.url}}/img/react/next13/routes.png)

이 바뀐 라우팅 시스템과 더불어 많은 예약파일들이 추가되었습니다.바뀐 라우팅 시스템과 예약파일들을 어떻게 쓰이는지 살펴보죠


새롭게 추가된 예약파일과 라우팅 구성
===
라우팅 되는 폴더에 여러가지 예약파일들이 추가되었습니다.
먼저 기본적으로 구성되는 예약파일들부터 알아보죠

### next/page
next/page는 기존의 next/index의 기능과 비슷하다고 보시면 될것 같습니다
각 라우팅되는 폴더에 기본적으로 page라고 하는 예약파일을 이용하여 경로의 세그먼트를 정의할 수 있습니다.

![next/page]({{site.url}}/img/react/next13/page.webp)


### next/layout
nextjs 13버전에서는 각 컴포넌트별로 사용할 레이아웃을 설정 할 수 있습니다.
또한 중첩으로도 레이아웃을 설정하거나 폴더별로 영향을 받지않게 다양하게 레이아웃을 설정할 수 있습니다.
동일 세그먼트에 존재하면 url 경로에 영향을 주지 않기 때문에 동일한 부모 레이아웃을 사용하는 경우 리렌더링도 발생하지 않습니다.!!

우선 layout의 종류로는 2가지로 나뉩니다.
```
Root Layout
Nesting Layout
```

#### Root Layout
RootLayout는 기존의 _app.js이나 _document.js와 같이 최상위 수준에서 모든 경로에 적용이 되며 *Root Layout*을 사용하면
서버에서 반환된 초기 HTML을 수정할 수 있습니다.
html및 body태그를 포함해야합니다.


```ts
export default function RootLayout({ children }: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

#### Nesting Layout

루트 레이아웃을 제외한 레이아웃들을 나타냅니다.폴더 내부에 정의된 레이아웃들은 해당 폴더 세그먼트에 적용이 됩니다.
파일 계층 구조의 레이아웃은 중첩 children이 되고 즉 자식 레이아웃을 래핑할수 있습니다.
![]({{site.url}}/img/next13/nested-layout.webp)

```ts 
export default function DashboardLayout({
  children
}: {
  children: React.ReactNode,
}){
  return <section>{children}</section>;
}
```

위와같이 중첩을 시켜놓으면 (app/layout.js)이 (app/dashboard/layouts.js)를 래핑하고
app/dashboar/* 세그먼트를 내부에 래핑합니다

두 레이아웃은 아래와 같이 중첩이됩니다.
![]({{site.url}}/img/react/next13/nested-layouts.png)


Route Groups
===
위에서 살펴보았던 것과 같이 폴더 구로에 따라 url이 매핑이됩니다. 
이렇게 되면 특정 폴더에 맞는 layout을 상속받아 사용할 수 밖에 없게 되는데 이럴 경우를 방지해서 url 구조에 영향을 주지 않는 경로를 구성할 수 있습니다.

몇가지 예시를 들어 살펴보죠

### 세그먼트에서 URL 경로에 영향을 받지않고 따로 세그먼트를 구성하는 경우.

괄호안에 폴더는 url에서 생략이 되며 (marketing) 경로가 내부에 있고 동일한 URL 구조를 공유하더라도 같은 level에 있는(shop)폴더를 추가하여 다른 레이아웃그룹을 만들 수 있습니다.
ex) (marketing) or (shop)
![]({{site.url}}/img/react/next13/route-group-organisation.webp)

### 레이아웃에서 특정 세그먼트 선택하는 경우
account,cart 세그먼트에 특정 레이아웃을 설정하고하 한다면 account,cart 폴더 상위에 (shop)이라는 폴더를 만들어 구분 지을 수 있습니다. 그룹외부의 경로인 checkout은 경로를 공유하지 않습니다.

![]({{site.url}}/img/react/next13/route-group-opt-in-layouts.webp)

### 여러가지 root 레이아웃 만들기
여러가지 root layout을 만들려면 최상위의 layout을 제거하고 각경로 그룹안에 파일 layout을 추가하여 줍니다.

![]({{site.url}}/img/react/next13/route-group-multiple-root-layouts.webp)



### next/template

next/template는 레이아웃과 해당 하위 세그먼트들을 래핑한다는 점에서 비슷하지만 여러 경로에서 사용되고 상태를 유지하는 next/layout과 달리
template 각 자식에대한 새 인트턴스만을 만듭니다.즉 사용자가 공유하는 세그먼트 경로로 이동을해도 next/template를 사용하면 다시 리렌더링이 된다는 말입니다.

상태가 유지가 되지않고 새로운 DOM요소로 다시 생성되기 때문에 아래와 같은 상황이 아니면 쓰지 않는걸 추천합니다.
```
- CSS또는 애니메이션 라이브러리를 사용하여 애니메이션 시작&종료
- useEffect 및 useState에 의존하는 기능
```

또한 next/layout과 next/template가 아래와 같이 공존하는 경우에는 next/layout안에 next/template가 존재하게 됩니다.
![]({{site.url}}/img/react/next13/template.webp)

```ts
<Layout>
  <Template>{children}</Template>
</Layout>
```

### next/head
디렉토리에서 HTML요소를 수정할 수 있습니다.

![]({{site.url}}/img/react/next13/head-file.webp)

```ts
async function getPost(slug) {
  const res = await fetch('...');
  return res.json();
}

export default async function Head({ params }) {
  const post = await getPost(params.slug);

  return (
    <>
      <title>{post.title}</title>
    </>
  )
}
```

head는 특정 태그만 반환할 수 있습니다.
- <title>
- <meta>
- <link>
- <script>

### next/loading

next13버전에서는 Instant Loading States라고하는 새로운 규칙이 도입되었습니다.
Instant Loading States를 사용하면 스켈레톤 및 스피너 같은 로딩 화면을 미리 렌더링 할 수 있습니다.

폴더안에 loading.js를 추가하여 사용합니다.
![]({{site.url}}/img/react/next13/loading-folder.webp)

app/dashboard/loading.tsx
```
export default function Loading() {
  // You can add any UI inside Loading, including a Skeleton.
  return <LoadingSkeleton />
}
```
더욱 세분화 된 로딩을 구현하고자 하면 react18에 나온 Suspense를 이용하면 될것 같습니다.

### next/error
error.js는 

폴더안에 error.js를 추가하여 사용합니다.
![]({{site.url}}/img/react/next13/error-folder.webp)



next/font와 next/image의 변화
---
둘의 공통적인 추가사항으로는 기존 로딩퍼포먼스를 저해하던 요소들을 개선하여 
layoutShift가 방지가 되었다는것이다. 
layoutshift란 이미지나 폰트같은 컨텐츠가 느리게 로딩이 되어 화면 레이아웃이 순간적으로 밀리게 되는 현상을 말합니다.

ex)

어떤식으로 바뀌어서 layoutShift를 방지하였는지 살펴보자.

next/image같은 경우에는 이전에는 이미지 파일이 크거나 이럴경우에는 로드되는 시간이 느린데
이미지가 화면상에 그려지지않고 로드 되는순간에는 이미지가 자동으로 최적화가되어서 이미지가 줄어들었다가 화면상에
이미지가 로드되었을 때 다시 밀려내려와서 Layoutshift현상이 발생했다 그래서 이걸 방지하기 위해 width와 height값을 고정으로 설정을 해 두었지만 nextJS의 13버전에서는 이러한 부분들이 해결이 되었다.

next/font는 nextjs자체적으로 google font가 내장이 되어 이제 cdn링크가 필요없어지게 되었다.
이전에는 _document.js 같이 cdn링크를 사용하여 google font를 가져왔습니다.

```ts
<Head>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="true" />
<link href="https://fonts.googleapis.com/css2?family=Anek+Malayalam:wght@200;300&family=Montserrat:wght@300;400&display=swap" rel="stylesheet" />
</Head>

```
하지만 아직까진 nextjs에 내장이 되어있는것이 아닌  @next/font를 다운 받아야 하며 그래야 구글 폰트가 적용이 됩니다.
```
npm install @next/font
or
yarn add @next/font
```
예를 들어 Ubuntu라고 하는 폰트를 가져오고 싶다면 아래와 같이 폰트를 가져와 적용을 시켜준면 된다.
```ts
import { Ubuntu} from '@next/font/google'
const ubuntu = Ubuntu({weight: '400'})

export default function Home() {
return (<h1 className={ubuntu.className}> Home page </h1> );
}

```

next/link
===
link태그 같은 경우에는 이전에 link태그 안에 a태그를 따로 설정을 해주어야 했지만
이번 13버전에서는 link태그 안에 바로 문자를 입력하여 a태그가 필요없게 되었습니다.
이제 기본태그에도 prop값을 전달 할 수 있게 되었습니다.

```ts
export default const Test=()=>{
  return(
    <>
      <link href='/test2'>Test이동</link>
    </>
  )
}
```





----------------------


React Server Component
---
렌더링환경
=== 
react server compoent를 살펴보기에 앞서 웹에서 렌더링하는 환경은 client와 server 이 두가지가 있습니다.
* client
client는 사용자들의 요청을 받아 서버로 보내고 서버의 응답을 사용자와 상호작용할수 있는 부분입니다.
* server
- server는 client의 요청을 수신하고 어떤 계산을하고 응답을 돌려주는 데이터센터를 말합니다.


///
ssr과 react server compoent의 차이점은?
===

기존 ssr을 이용하여 렌더링하는 경우 정적인 HTML을 받아서 렌더링한 후 js번들파일이 클라이언트에서 다 받아지면 hydration 작업이 일어나 js번들파일이 동적인 기능을 수행하게 하였습니다.하지만 이러한 상호작용은 hydration이 일어난 이후에는 다시 사용할 수 없습니다.

react server compoent를 사용하게 되면 정


Client_Side에서의 JS Bundle을 줄여주는것이 핵심입니다.
///


SSR과 Server Component 비교
===
Server Component의 코드는 Client에 전송이 되지 않으며 SSR은 모든 Component코드가 JS번들로 전송됩니다.
Server Component를 사용하면 Compoent Tree 어디에서나 backend로 접근이 가능하며 기존 Next.js 에서는 getServerProps가 접근할 수 있었지만 최상위에서만 사용이 가능하여 Component화가 제한적이였다.
Server Compoent는 Tree 내부의 client state를 잃지 않고 다시 설정 할 수 있다.






RSC를 활용하면 서버와 브라우저의 강점을 잘 살려 서버 컴포넌트들은 데이터를 가져오고 콘ㅌ



이전까지는 페이지 전체를 서버에서 렌더링하는 SSR이 주였지만 Server Component를 사용하게 되면 일부만 서버에서 렌더링 한 후
페이지에 주입하는 것이 가능하게 됩니다.


React 18버전 이전에는 React를 이용하여 렌더링하는 기본 방법은 클라이언트였습니다.
일반적인 서버사이드 렌더링은 
Next.js에서 렌더링을 하는 경우는 HTML을 생성하고 Hydration이 되도록 서버에서 클라이언트에 전송을 하여 어플리케이션을
 page폴더로 나누고 서버에서 미리 렌더링하는 방법을 제공하였습니다.하지만 이렇게 하기 위해선 클러이언트단에 추가적인 JS가 필요했습니다.
 
 하지만 React Server Component를 사용하면 컴포넌트를 정기적으로 다시 가져올 수 있게 되어
 이제 app디렉토리에서 기본적으로 서버 컴포넌트를 사용하므로 서버 컴포넌트를 조금 더 쉽게 렌더링하고 클라이언트에 전송되는 Js의번들 크기의 양을
 줄일 수 있습니다.그리고 컴포넌트 내부에서 서버 컴포넌트를 사용할지 클라이언트 컴포넌트를 사용할지 선택할 수 있습니다.

![]({{site.url}}/img/next13/component-tree.webp)





경로가 로드되면 

### Client Component
자동으로 서버 컴포넌트가 적용이 되기 때문에 클라이언트의 구성요소를 사용하려면 아래와 같이 상단 지시문에 'use client'를 선언을 해주어야 합니다.

```ts
'use client';

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```


#### 그렇다면 클라이언트 컴포넌트는 언제 사용해야 될까요?

![]({{site.url}}/img/next13/server-vs-client.webp)

전반적으로 서버와 통신을하거나 할때는 서버 컴포넌트사용 클라이언트 관련 기능이나 변경사항이 있으면 클라이언트 컴포넌트를 사용하면 될것 같습니다.



### 외부 라이브러리에서 client 컴포넌트 사용
'use client'는 서버 컴포넌트의 일부로 새롭게 도입된 기능입니다.서버 컴포넌트가 새롭기 때문에 
오늘날 클라이언트 전용 기능을 사용하는 npm 패키지의 많은 구성 요소에는 아직 지시문이 없습니다. 
이러한 타사 구성 요소는 자체적으로 "use client"지시문이 있기 때문에 자체 클라이언트 구성 요소 내에서 예상대로 작동하지만 서버 구성 요소 내에서는 작동하지 않습니다.

예를들어 서버컴포넌트에서 acme-carousel의 컴포넌트를 사용하려고 합니다.

```ts
import { AcmeCarousel } from 'acme-carousel';

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* 🔴 Error: `useState` can not be used within Server Components */}
      <AcmeCarousel />
    </div>
  );
}
```
하지만 Next.js에서는 AcmeCarousel가 클라이언트 기능을 사용하고 있다는 것을 모르기 때문에 에러가 뜹니다.
이러한 부분을 해결하기위해 타사의 컴포넌트를 래핑해줘야합니다.

```ts
'use client';

import { AcmeCarousel } from 'acme-carousel';

export default AcmeCarousel;
```

<Carousel />이제 서버 구성 요소 내에서 직접 사용할 수 있습니다 .

```ts
import Carousel from './carousel';

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* 🟢 Works, since Carousel is a Client Component */}
      <Carousel />
    </div>
  );
}
```


fetch의 변화
---

이제 데이터를 가져올 때 getStaticProps,getServerSideProps를 쓰지 않아도 됩니다.
왜냐면 이제 fetch에서 이 두가지 함수의 기능을 제공하기 때문이죠.app 디렉토리에서 데이터를 가져오고 캐싱하여 유효성 검사를 다시하는 방법이 있습니다.

Server Compoent는 항상 서버에서 data를 fetching한다.
Server Componet에서는 데이터를 가져오면 이 가져오기 패턴을 통해 아래와 같은 이점들이 존재한다.
- 백엔드 데이터를 클라이언트단에서 실행되지 않기 때문에 직접 액세스 할 수 있음.
- 액세스 토큰 및 api 키와 같은 민감한 정보를 서버에 보관하여 어플리케이션을 쉽고 안전하게 보호한다.
- 데이터를 가져오고 동일한 환경에서 컴포넌트를 렌더링합니다. 이렇게 하면 클라이언트와 서버간의 양방향 통신과 클라이언트 측의 작업이 줄어듭니다.
- 클라이언트에서 여러 개별 요청 대신 단일 왕복으로 여러 데이터를 가져올 수 있다.
- client-server waterfall현상이 줄어듭니다.
- Server Copmpoent는 Js번들을 보내지 않기 때문에 클라이언트의 JsBundle 크기가 줄어듭니다.


fetch api 및 비동기 component




데이터 가져오는것에 있어서도 변화가 있습니다.

```ts
// 이 요청은 수동으로 제어할때까지 캐시 되어이습니다.
//  getStaticProp와 유사합니다.'force-cache'는 기본값이며 생략할 수 있습니다.
fetch(URL, { cache: 'force-cache' });

// 이 요청은 모든 요청에 다시 가져옴
// getServerSideProps와 유사합니다.
fetch(URL, { cache: 'no-store' });

// 이 요청은 10초의 수명으로 캐싱됨
// revalidate옵션은 getStaticProps와 비슷합니다.
fetch(URL, { next: { revalidate: 10 } });
```


data fetch
===

```ts
// app/page.js
async function getData() {
  const res = await fetch('https://api.example.com/...');
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.
  return res.json();
}

// This is an async Server Component
export default async function Page() {
  const data = await getData();

  return <main>{/* ... */}</main>;
}
```



Turbopack
---
turbopack을 써서 vite보다 속도가 10배가 빨라졌다고 하네요.
최근에 사이드 프로젝트로 react개발을 vite라고 하는 번들러를 통해 개발을 했었는데
vite를 통해 빌드할때도 빌드속도가 엄청 빨랐다고 느껴졌는데 이것보다 더 빨라졌다니
역시 발전하는속도가 장난이 아니네요...

nextjs에서의 공식문서상에서는

```
Webpack보다 700배 빠른 업데이트
Vite보다 10배 빠른 업데이트
Webpack보다 4배 빠른 콜드 스타트
```
라고 규정해놓았는데요.

![터보팩 스피드 비교]({{site.url}}/img/next13/turbopack-speed.avif)


https://github.com/yyx990803/vite-vs-next-turbo-hmr/discussions/8

여기 내용상으로는 nextjs의 turbopack이 10배 빠른 업데이트가 일어나려면 아래의 전제 조건들이 갖추어 져야 한다고 합니다.
1. vite가 swc변환을 사용하지 않는다.
2. 응용프로그램에는 3000개 이상의 모듈이 포함이 되어있다.
3. 벤치마크는 핫 업데이트된 모듈이 평가되는 시간만 측정하지만 변경 사항이 실제로 적용될 때는 측정하지 않습니다.


후기
===
큰틀에선 바뀐게 많이~


출처 : https://nextjs.org/blog/next-13
https://www.youtube.com/watch?v=_w0Ikk4JY7U
https://medium.com/nextjs/how-to-use-font-optimizing-in-nextjs-13-7a66c450a88a